#!/usr/bin/env python3
"""
LaTeX to PDF converter for resume workspace.

Usage:
    python convert_resume.py                    # Convert all .tex files
    python convert_resume.py file.tex           # Convert single file
    python convert_resume.py finance/           # Convert all in directory
    python convert_resume.py --clean            # Remove auxiliary files after conversion
    python convert_resume.py --dry-run          # Show what would be converted
"""

import argparse
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import List, Optional


@dataclass
class ConversionResult:
    """Result of a single file conversion."""
    tex_file: Path
    success: bool
    error_message: str = ""
    pdf_path: Optional[Path] = None


class LatexConverter:
    """Handles LaTeX to PDF conversion."""

    # Auxiliary files generated by pdflatex
    AUX_EXTENSIONS = ['.aux', '.log', '.out', '.toc', '.nav', '.snm', '.vrb']

    def __init__(self, workspace_root: Path):
        self.workspace_root = workspace_root
        self.pdflatex_path = self._find_pdflatex()

    def _find_pdflatex(self) -> str:
        """Locate pdflatex executable."""
        # Check common locations
        common_paths = [
            '/Library/TeX/texbin/pdflatex',  # macOS TeX Live
            '/usr/bin/pdflatex',              # Linux
            '/usr/local/bin/pdflatex',        # Alternative Linux
        ]

        for path in common_paths:
            if Path(path).exists():
                return path

        # Fall back to PATH lookup
        try:
            result = subprocess.run(
                ['which', 'pdflatex'],
                capture_output=True,
                text=True
            )
            if result.returncode == 0:
                return result.stdout.strip()
        except Exception:
            pass

        raise RuntimeError(
            "pdflatex not found. Please install TeX Live or MiKTeX."
        )

    def find_tex_files(self, target: Optional[Path] = None) -> List[Path]:
        """Find all .tex files in workspace or specific target."""
        if target is None:
            target = self.workspace_root

        target = Path(target)

        if target.is_file() and target.suffix == '.tex':
            return [target]

        if target.is_dir():
            # Find all .tex files recursively
            return sorted(target.rglob('*.tex'))

        return []

    def convert_file(self, tex_file: Path, clean: bool = False) -> ConversionResult:
        """
        Convert a single .tex file to PDF.

        Runs pdflatex twice for proper reference resolution.
        """
        tex_file = Path(tex_file).resolve()

        if not tex_file.exists():
            return ConversionResult(
                tex_file=tex_file,
                success=False,
                error_message=f"File not found: {tex_file}"
            )

        if tex_file.suffix != '.tex':
            return ConversionResult(
                tex_file=tex_file,
                success=False,
                error_message=f"Not a .tex file: {tex_file}"
            )

        # Work in the directory containing the .tex file
        working_dir = tex_file.parent
        filename = tex_file.name

        # pdflatex command with common options
        cmd = [
            self.pdflatex_path,
            '-interaction=nonstopmode',  # Don't stop on errors
            '-halt-on-error',            # But do halt on serious errors
            '-file-line-error',          # Better error messages
            filename
        ]

        try:
            # Run pdflatex twice for proper reference resolution
            for pass_num in range(2):
                result = subprocess.run(
                    cmd,
                    cwd=working_dir,
                    capture_output=True,
                    text=True,
                    timeout=60  # 60 second timeout per pass
                )

                if result.returncode != 0:
                    # Extract meaningful error from log
                    error_msg = self._extract_error(result.stdout, result.stderr)
                    return ConversionResult(
                        tex_file=tex_file,
                        success=False,
                        error_message=f"pdflatex failed (pass {pass_num + 1}): {error_msg}"
                    )

            # Verify PDF was created
            pdf_path = tex_file.with_suffix('.pdf')
            if not pdf_path.exists():
                return ConversionResult(
                    tex_file=tex_file,
                    success=False,
                    error_message="PDF file was not created"
                )

            # Clean auxiliary files if requested
            if clean:
                self._clean_aux_files(tex_file)

            return ConversionResult(
                tex_file=tex_file,
                success=True,
                pdf_path=pdf_path
            )

        except subprocess.TimeoutExpired:
            return ConversionResult(
                tex_file=tex_file,
                success=False,
                error_message="Compilation timed out (>60s)"
            )
        except Exception as e:
            return ConversionResult(
                tex_file=tex_file,
                success=False,
                error_message=str(e)
            )

    def _extract_error(self, stdout: str, stderr: str) -> str:
        """Extract meaningful error message from pdflatex output."""
        # Look for common error patterns in stdout (pdflatex outputs to stdout)
        lines = stdout.split('\n')

        error_lines = []
        for i, line in enumerate(lines):
            # LaTeX errors start with '!'
            if line.startswith('!'):
                error_lines.append(line)
                # Include following context lines
                for j in range(i + 1, min(i + 3, len(lines))):
                    if lines[j].strip():
                        error_lines.append(lines[j])
                break

        if error_lines:
            return ' '.join(error_lines[:3])

        # Fall back to stderr or generic message
        if stderr.strip():
            return stderr.strip()[:200]

        return "Unknown error (check .log file)"

    def _clean_aux_files(self, tex_file: Path):
        """Remove auxiliary files generated by pdflatex."""
        base = tex_file.with_suffix('')
        for ext in self.AUX_EXTENSIONS:
            aux_file = base.with_suffix(ext)
            if aux_file.exists():
                aux_file.unlink()

    def convert_batch(
        self,
        tex_files: List[Path],
        clean: bool = False,
        verbose: bool = True
    ) -> List[ConversionResult]:
        """Convert multiple .tex files."""
        results = []

        for i, tex_file in enumerate(tex_files, 1):
            if verbose:
                rel_path = tex_file.relative_to(self.workspace_root) \
                    if tex_file.is_relative_to(self.workspace_root) else tex_file
                print(f"[{i}/{len(tex_files)}] Converting: {rel_path}")

            result = self.convert_file(tex_file, clean=clean)
            results.append(result)

            if verbose:
                if result.success:
                    print(f"    SUCCESS: {result.pdf_path.name}")
                else:
                    print(f"    FAILED: {result.error_message}")

        return results


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description='Convert LaTeX resume files to PDF',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    %(prog)s                      Convert all .tex files in workspace
    %(prog)s file.tex             Convert a single file
    %(prog)s finance/             Convert all .tex files in finance/
    %(prog)s --clean              Clean auxiliary files after conversion
    %(prog)s --dry-run            Show files that would be converted
        """
    )

    parser.add_argument(
        'target',
        nargs='?',
        default=None,
        help='File or directory to convert (default: all .tex files)'
    )

    parser.add_argument(
        '--clean', '-c',
        action='store_true',
        help='Remove auxiliary files (.aux, .log, .out, etc.) after conversion'
    )

    parser.add_argument(
        '--dry-run', '-n',
        action='store_true',
        help='Show what would be converted without actually converting'
    )

    parser.add_argument(
        '--quiet', '-q',
        action='store_true',
        help='Suppress progress output'
    )

    args = parser.parse_args()

    # Determine workspace root (directory containing this script)
    workspace_root = Path(__file__).parent.resolve()

    try:
        converter = LatexConverter(workspace_root)
    except RuntimeError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

    # Resolve target path
    if args.target:
        target = Path(args.target)
        if not target.is_absolute():
            target = workspace_root / target
    else:
        target = workspace_root

    # Find files to convert
    tex_files = converter.find_tex_files(target)

    if not tex_files:
        print(f"No .tex files found in: {target}")
        sys.exit(0)

    # Dry run mode
    if args.dry_run:
        print(f"Would convert {len(tex_files)} file(s):")
        for tex_file in tex_files:
            rel_path = tex_file.relative_to(workspace_root) \
                if tex_file.is_relative_to(workspace_root) else tex_file
            print(f"  {rel_path}")
        sys.exit(0)

    # Perform conversion
    results = converter.convert_batch(
        tex_files,
        clean=args.clean,
        verbose=not args.quiet
    )

    # Summary
    succeeded = sum(1 for r in results if r.success)
    failed = sum(1 for r in results if not r.success)

    if not args.quiet:
        print(f"\n{'='*50}")
        print(f"Conversion complete: {succeeded} succeeded, {failed} failed")

    # Exit with error code if any failures
    sys.exit(1 if failed > 0 else 0)


if __name__ == '__main__':
    main()
